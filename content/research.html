
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8">
        <style>
            pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #49483e }
.codehilite { background: #272822; color: #F8F8F2 }
.codehilite .c { color: #959077 } /* Comment */
.codehilite .err { color: #ED007E; background-color: #1E0010 } /* Error */
.codehilite .esc { color: #F8F8F2 } /* Escape */
.codehilite .g { color: #F8F8F2 } /* Generic */
.codehilite .k { color: #66D9EF } /* Keyword */
.codehilite .l { color: #AE81FF } /* Literal */
.codehilite .n { color: #F8F8F2 } /* Name */
.codehilite .o { color: #FF4689 } /* Operator */
.codehilite .x { color: #F8F8F2 } /* Other */
.codehilite .p { color: #F8F8F2 } /* Punctuation */
.codehilite .ch { color: #959077 } /* Comment.Hashbang */
.codehilite .cm { color: #959077 } /* Comment.Multiline */
.codehilite .cp { color: #959077 } /* Comment.Preproc */
.codehilite .cpf { color: #959077 } /* Comment.PreprocFile */
.codehilite .c1 { color: #959077 } /* Comment.Single */
.codehilite .cs { color: #959077 } /* Comment.Special */
.codehilite .gd { color: #FF4689 } /* Generic.Deleted */
.codehilite .ge { color: #F8F8F2; font-style: italic } /* Generic.Emph */
.codehilite .ges { color: #F8F8F2; font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #F8F8F2 } /* Generic.Error */
.codehilite .gh { color: #F8F8F2 } /* Generic.Heading */
.codehilite .gi { color: #A6E22E } /* Generic.Inserted */
.codehilite .go { color: #66D9EF } /* Generic.Output */
.codehilite .gp { color: #FF4689; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { color: #F8F8F2; font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #959077 } /* Generic.Subheading */
.codehilite .gt { color: #F8F8F2 } /* Generic.Traceback */
.codehilite .kc { color: #66D9EF } /* Keyword.Constant */
.codehilite .kd { color: #66D9EF } /* Keyword.Declaration */
.codehilite .kn { color: #FF4689 } /* Keyword.Namespace */
.codehilite .kp { color: #66D9EF } /* Keyword.Pseudo */
.codehilite .kr { color: #66D9EF } /* Keyword.Reserved */
.codehilite .kt { color: #66D9EF } /* Keyword.Type */
.codehilite .ld { color: #E6DB74 } /* Literal.Date */
.codehilite .m { color: #AE81FF } /* Literal.Number */
.codehilite .s { color: #E6DB74 } /* Literal.String */
.codehilite .na { color: #A6E22E } /* Name.Attribute */
.codehilite .nb { color: #F8F8F2 } /* Name.Builtin */
.codehilite .nc { color: #A6E22E } /* Name.Class */
.codehilite .no { color: #66D9EF } /* Name.Constant */
.codehilite .nd { color: #A6E22E } /* Name.Decorator */
.codehilite .ni { color: #F8F8F2 } /* Name.Entity */
.codehilite .ne { color: #A6E22E } /* Name.Exception */
.codehilite .nf { color: #A6E22E } /* Name.Function */
.codehilite .nl { color: #F8F8F2 } /* Name.Label */
.codehilite .nn { color: #F8F8F2 } /* Name.Namespace */
.codehilite .nx { color: #A6E22E } /* Name.Other */
.codehilite .py { color: #F8F8F2 } /* Name.Property */
.codehilite .nt { color: #FF4689 } /* Name.Tag */
.codehilite .nv { color: #F8F8F2 } /* Name.Variable */
.codehilite .ow { color: #FF4689 } /* Operator.Word */
.codehilite .pm { color: #F8F8F2 } /* Punctuation.Marker */
.codehilite .w { color: #F8F8F2 } /* Text.Whitespace */
.codehilite .mb { color: #AE81FF } /* Literal.Number.Bin */
.codehilite .mf { color: #AE81FF } /* Literal.Number.Float */
.codehilite .mh { color: #AE81FF } /* Literal.Number.Hex */
.codehilite .mi { color: #AE81FF } /* Literal.Number.Integer */
.codehilite .mo { color: #AE81FF } /* Literal.Number.Oct */
.codehilite .sa { color: #E6DB74 } /* Literal.String.Affix */
.codehilite .sb { color: #E6DB74 } /* Literal.String.Backtick */
.codehilite .sc { color: #E6DB74 } /* Literal.String.Char */
.codehilite .dl { color: #E6DB74 } /* Literal.String.Delimiter */
.codehilite .sd { color: #E6DB74 } /* Literal.String.Doc */
.codehilite .s2 { color: #E6DB74 } /* Literal.String.Double */
.codehilite .se { color: #AE81FF } /* Literal.String.Escape */
.codehilite .sh { color: #E6DB74 } /* Literal.String.Heredoc */
.codehilite .si { color: #E6DB74 } /* Literal.String.Interpol */
.codehilite .sx { color: #E6DB74 } /* Literal.String.Other */
.codehilite .sr { color: #E6DB74 } /* Literal.String.Regex */
.codehilite .s1 { color: #E6DB74 } /* Literal.String.Single */
.codehilite .ss { color: #E6DB74 } /* Literal.String.Symbol */
.codehilite .bp { color: #F8F8F2 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #A6E22E } /* Name.Function.Magic */
.codehilite .vc { color: #F8F8F2 } /* Name.Variable.Class */
.codehilite .vg { color: #F8F8F2 } /* Name.Variable.Global */
.codehilite .vi { color: #F8F8F2 } /* Name.Variable.Instance */
.codehilite .vm { color: #F8F8F2 } /* Name.Variable.Magic */
.codehilite .il { color: #AE81FF } /* Literal.Number.Integer.Long */
            .codehilite {
                background-color: #272822;
                border: 1px solid #ccc;
                padding: 5px;
                margin: 10px 0;
                overflow: auto;
            }
            .codehilite pre {
                margin: 0;
                padding: 0;
            }
            .codehilite code {
                background-color: transparent;
                padding: 0;
            }
        </style>
    </head>
    <body><h2>Research</h2>
<h3>Mechanism Design for Trading Information</h3>
<p><a href="">Falconer, T., Kazempour, J., &amp; Pinson, P. (2024). <em>Trading Information in Games</em>. (Work in progress).</a></p>
<h3>Collaborative Machine Learning</h3>
<p><a href="https://www.jmlr.org/papers/v25/23-1385.html">Falconer, T., Kazempour, J., &amp; Pinson, P. (2024). <em>Bayesian Regression Markets</em>. Journal of Machine Learning Research, 25 (180), 1â€“38.</a></p>
<p><strong>Abstract</strong>: Although machine learning tasks are highly sensitive to the quality of input data, relevant datasets can often be challenging for firms to acquire, especially when held privately by a variety of owners. For instance, if these owners are competitors in a downstream market, they may be reluctant to share information. Focusing on supervised learning for regression tasks, we develop a regression market to provide a monetary incentive for data sharing. Our mechanism adopts a Bayesian framework, allowing us to consider a more general class of regression tasks. We present a thorough exploration of the market properties, and show that similar proposals in literature expose the market agents to sizeable financial risks, which can be mitigated in our setup.</p>
<p><a href="https://arxiv.org/abs/2310.06000">Falconer, T., Kazempour, J., &amp; Pinson, P. (2024). <em>Towards Replication-Robust Analytics Markets</em>. arXiv Preprint (Under Review).</a></p>
<p><strong>Abstract</strong>: Despite the widespread use of machine learning throughout industry, many firms face a common challenge: relevant datasets are typically distributed amongst market competitors that are reluctant to share information. Recent works propose analytics markets as a way to provide monetary incentives for data sharing, however many designs are vulnerable to malicious forms of replication, where agents replicate their data and act under false identities to increase revenue, and in turn diminish that of others. Accordingly, we develop a replication-robust analytics market for supervised learning problems. To allocate revenue, we treat features of agents as players and their interactions as a characteristic function game. We show that there are several different ways to describe such a game, each having causal nuances that impact robustness to replication. Our methodology is validated using a real-world wind power forecasting case study.</p>
<h3>Machine Learning for Power Systems Operations</h3>
<p><a href="https://ieeexplore.ieee.org/abstract/document/9810496">Falconer, T. &amp; and Mones, L. (2023). <em>Leveraging Power Grid Topology in Machine Learning Assisted Optimal Power Flow</em>. IEEE Transactions on Power Systems, 38 (3), 2234-2246</a></p>
<p><strong>Abstract</strong>: Machine learning assisted optimal power flow (OPF) aims to reduce the computational complexity of these non-linear and non-convex constrained optimization problems by consigning expensive (online) optimization to offline training. The majority of work in this area typically employs fully connected neural networks (FCNN). However, recently convolutional (CNN) and graph (GNN) neural networks have also been investigated, in effort to exploit topological information within the power grid. Although promising results have been obtained, there lacks a systematic comparison between these architectures throughout literature. Accordingly, we introduce a concise framework for generalizing methods for machine learning assisted OPF and assess the performance of a variety of FCNN, CNN and GNN models for two fundamental approaches in this domain: regression (predicting optimal generator set-points) and classification (predicting the active set of constraints). For several synthetic power grids with interconnected utilities, we show that locality properties between feature and target variables are scarce and subsequently demonstrate marginal utility of applying CNN and GNN architectures compared to FCNN for a fixed grid topology. However, with variable topology (for instance, modeling transmission line contingency), GNN models are able to straightforwardly take the change of topological information into account and outperform both FCNN and CNN models.</p></body>
    </html>
    